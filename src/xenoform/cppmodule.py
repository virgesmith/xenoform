import subprocess
from dataclasses import dataclass, field
from enum import StrEnum
from hashlib import sha256
from typing import Self

import clang_format  # type: ignore[import-untyped]
from itrx import Itr

from xenoform import __version__ as version
from xenoform.logger import get_logger
from xenoform.utils import build_freethreaded, deduplicate, group_headers

logger = get_logger()


_module_template = """
// generated by xenoform {version}
// cxx_std: {cxx_std}
// defines: {define_macros}
// extra include paths: {extra_include_paths}
// extra cxxflags: {extra_compile_args}
// extra ldflags: {extra_link_args}

{headers}

namespace py = pybind11;
using namespace py::literals;

PYBIND11_MODULE({module_name}, m{freethreaded}) {{
  m.doc() = "{module_name} module generated by xenoform {version}";
  m.attr("__checksum__") = "__HASH__";
  {function_definitions}
}}
"""

_function_template = """
  m.def("{function_name}", {function_body}, {return_value_policy} {help} {arg_defs});

"""


class ReturnValuePolicy(StrEnum):
    """See https://pybind11.readthedocs.io/en/stable/advanced/functions.html#return-value-policies"""

    TakeOwnership = "py::return_value_policy::take_ownership"
    Copy = "py::return_value_policy::copy"
    Move = "py::return_value_policy::move"
    Reference = "py::return_value_policy::reference"
    ReferenceInternal = "py::return_value_policy::reference_internal"
    Automatic = "py::return_value_policy::automatic"
    AutomaticReference = "py::return_value_policy::automatic_reference"


@dataclass(frozen=True)
class FunctionSpec:
    """
    Dataclass defining a function
    """

    name: str
    body: str
    arg_annotations: str
    scope: tuple[str, ...]
    return_value_policy: ReturnValuePolicy
    help: str | None = None

    def qualified_cpp_name(self) -> str:
        if self.scope:
            return f"_{'_'.join(self.scope)}_{self.name}"
        return f"_{self.name}"


@dataclass
class ModuleSpec:
    """
    Dataclass for accumulating functions to be built within a module
    """

    functions: set[FunctionSpec] = field(default_factory=set[FunctionSpec])
    headers: list[str] = field(default_factory=list[str])
    include_paths: list[str] = field(default_factory=list[str])
    define_macros: list[str] = field(default_factory=list[str])
    extra_compile_args: list[str] = field(default_factory=list[str])
    extra_link_args: list[str] = field(default_factory=list[str])
    cxx_std: int | None = None

    def add_function(
        self,
        function: FunctionSpec,
        *,
        headers: list[str] | None = None,
        include_paths: list[str] | None = None,
        define_macros: list[str] | None = None,
        extra_compile_args: list[str] | None = None,
        extra_link_args: list[str] | None = None,
        cxx_std: int = 20,
    ) -> Self:
        self.functions.add(function)
        self.headers += headers or []
        self.include_paths += include_paths or []
        self.define_macros += define_macros or []
        self.extra_compile_args += extra_compile_args or []
        self.extra_link_args += extra_link_args or []
        if self.cxx_std and self.cxx_std != cxx_std:
            raise ValueError(
                "Requested C++ standard {} conflicts with previously set standard. Ensure only one standard per module"
            )
        self.cxx_std = cxx_std
        return self

    def make_source(self, module_name: str) -> tuple[str, str]:
        headers = Itr(group_headers(self.headers)).flatten().fold("", lambda hs, h: hs + f"#include {h}\n")

        # sort to prevent rebuilding when nothing has changed but the function ordering
        function_defs = "\n".join(
            sorted(
                _function_template.format(
                    function_name=f.qualified_cpp_name(),
                    function_body=f.body,
                    arg_defs=f.arg_annotations,
                    return_value_policy=f.return_value_policy,
                    help=f', R"""({f.help})"""' if f.help else "",
                )
                for f in self.functions
            )
        )

        disable_gil_flag = ", py::mod_gil_not_used()" if build_freethreaded() else ""

        # create the code without the hash
        code = _module_template.format(
            version=version,
            cxx_std=self.cxx_std,
            headers=headers,
            extra_include_paths=deduplicate(self.include_paths),
            # do we need to deduplicate? or will this break something?
            define_macros=" ".join(self.define_macros),
            extra_compile_args=" ".join(deduplicate(self.extra_compile_args)),
            extra_link_args=" ".join(self.extra_link_args),
            module_name=module_name,
            freethreaded=disable_gil_flag,
            function_definitions=function_defs,
        )

        try:
            result = subprocess.run(
                [clang_format.get_executable("clang-format")], input=code, capture_output=True, text=True, check=True
            )
        except subprocess.CalledProcessError as e:
            logger(f"clang-format failed: {e}. module.cpp will be unformatted")
        else:
            code = result.stdout

        # return code and hash
        return code, sha256(code.encode()).hexdigest()
